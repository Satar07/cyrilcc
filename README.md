**寄存器角色:** 类 MIPS

- R0: FLAG
- R1: IP
- R15: IO 读取保存
- R2: 返回值
- R2-R5: 参数寄存器，前四个参数
- R8 R9 R10 R13: 临时/暂存寄存器 调用者保存
- R11: FP 被调用者保存
- R12: SP 被调用者保存
- R14: RA 返回地址 call设置 ret读取
- R6 R7 暂时未使用

**栈帧布局:** (栈向下增长)

```
+-------------------+
| ...               |  <-- Caller's Stack
| Arg 5             |
| Arg 4             |
+-------------------+ ---
| Old FP            |  \
+-------------------+  | Callee's Frame
| Return Address    |  | (Pushed by callee)
+-------------------+ ---  <-- R11 (FP) points here
| Local Var 1       |  |
+-------------------+  |
| IR Temp %0        |  |
+-------------------+  |
| IR Temp %1        |  /
+-------------------+ ---  <-- R12 (SP) points here

```

**函数调用 (`CALL`) 流程:**

**调用者 (Caller):**

1. (如有) 保存所有需要保留的*调用者保存*寄存器 (`R8-R10, R13`) 到自己的栈帧。
2. 将参数 0-3 加载到 `R2-R5`。
3. 将参数 4+ (如果有) *逆序*压入栈中。
4. `LOD R14, <return_label>`: 设置返回地址。
5. `JMP <func_label>`: 跳转。
6. 到返回位置 `<return_label>:`:
7. (如有) 清理栈上的参数。
8. (如有) 从 `R2` 获取返回值。
9. (如有) 恢复*调用者保存*的寄存器。

**被调用者 (Callee):**

1. `STO (R12), R11`: 压入旧 FP。
2. `SUB R12, #4`
3. `STO (R12), R14`: 压入 RA。
4. `SUB R12, #4`
5. `LOD R11, R12`: 设置新 FP。
6. `SUB R12, #frame_size`: 为局部变量和临时变量分配空间。
7. (如有) 将 `R2-R5` 中的参数保存到它们在栈上的“主页”。
8. ... 执行函数体 ...

**返回 (`RET`) 流程 (在 Callee 中):**

1. (如有) 将返回值加载到 `R2`。
2. `LOD R12, R11`: 释放局部变量空间。
3. `LOD R14, (R12 + 4)`: 恢复 RA。
4. `LOD R11, (R12 + 8)`: 恢复旧 FP。
5. `ADD R12, #8`: 恢复 SP。
6. `JMP R14`: 返回。
